#include<bits/stdc++.h>
using namespace std;

const int N = 20;
int n;

char g[N][N];
bool row[N],col[N],dg[N],udg[N];//用一维数组表示二维的对角线  因为他们的和都是相等的

void dfs(int x,int y,int z)
{
    if(y==n) {y=0;x++;}
    if(x==n){
        if(z==n){
            for(int i=0;i<n;i++) puts(g[i]);
            puts("");
        }
        return;
    }
    //关于剪枝问题  如果先放就能更快的找到一个解，如果先不放相对慢，但是本题需要遍历所有的点故从本题而言是一样的
    
    //不放皇后
    dfs(x,y+1,z);
    //放皇后
    if(!row[x] && !col  [y] && !dg[x+y] && !udg[x-y+n]){
        g[x][y] = 'Q';
        row[x] = col[y] = dg[x+y] = udg[x-y+n] = true;
        dfs(x,y+1,z+1);
        row[x] = col[y] = dg[x+y] = udg[x-y+n] = false;
        g[x][y] = '.';
    }
}


int main()
{
    cin >> n;
    for(int i=0;i<n;i++){
        for(int j=0;j<n;j++){
            g[i][j] = '.';
            // cout << g[i][j] << " ";
        }
    }
    dfs(0,0,0);
    return 0;
}